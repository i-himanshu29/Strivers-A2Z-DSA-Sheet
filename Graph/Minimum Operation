/*
PROBLEM:
Given start, end, and an array arr of n numbers. At each step, the start is multiplied by any number in the array and
then a mod operation with 100000 is done to get the new start.
Your task is to find the minimum steps in which the end can be achieved starting from the start. If it is not possible to reach the end, then return -1.
*/

int minimumOperations(int n,int start,int end,vector<int> &a)
{
    if(start==end)return 0;
    int mod=1000;
    vector<int>dist(1000,INT_MAX);

    typedef pair<int,int>p;
    priority_queue<p,vector<p>,greater<p>>pq;
    pq.push({0,start});
    dist[start]=0;

    while(!pq.empty())
    {
        auto top=pq.top();pq.pop();
        int opn=top.first;
        int node=top.second;
        
        if(node==end) return dist[node];

        for(auto i:a)
        {
            int nopn=opn+1;
            int nnode=(node*i)%mod;

            if(nopn<dist[nnode])
            {
                dist[nnode]=nopn;
                pq.push({nopn,nnode});
            }
        }
    }
    return -1;
}

//SOLVE ON CODING NINJA

Time Complexity : O(100000 * N) 

Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers 
of which each node could be multiplied.

Space Complexity :  O(100000 * N) 

Where ‘100000’ are the total possible numbers generated by multiplication (hypothetical) and
N = size of the array with numbers of which each node could be multiplied. 100000 * N is the max possible queue size.
The space complexity of the dist array is constant.
