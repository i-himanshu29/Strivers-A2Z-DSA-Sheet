/*
PROBLEM:
There are n cities and m edges connected by some number of Trains. You are given an array of trains where trains[i] = [ fromi, toi, pricei] indicates
that there is a train from city fromi to city toi with cost price. You have also given three integers src, dst, and k, 
and return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.


*/


int savingMoney(int n, int source, int destination, int K, vector<vector<int>> &trains)
{
     // Create the adjacency list to depict airports and flights in
        // the form of a graph.
        vector<pair<int, int>> adj[n];
        for (auto it : trains)
        {
            adj[it[0]].push_back({it[1], it[2]});
        }

        // Create a queue which stores the node and their distances from the
        // source in the form of {stops, {node, dist}} with ‘stops’ indicating 
        // the no. of nodes between src and current node.
        queue<pair<int, pair<int, int>>> q;
        
        q.push({0, {source, 0}});

        // Distance array to store the updated distances from the source.
        vector<int> dist(n, 1e9);
        dist[source] = 0;

        // Iterate through the graph using a queue like in Dijkstra with 
        // popping out the element with min stops first.
        while (!q.empty())
        {
            auto it = q.front();
            q.pop();
            int stops = it.first;
            int node = it.second.first;
            int cost = it.second.second;

            // We stop the process as soon as the limit for the stops reaches.
            if (stops > K)
                continue;
            for (auto iter : adj[node])
            {
                int adjNode = iter.first;
                int edW = iter.second;

                // We only update the queue if the new calculated dist is
                // less than the prev and the stops are also within limits.
                if (cost + edW < dist[adjNode] && stops <= K)
                {
                    dist[adjNode] = cost + edW;
                    q.push({stops + 1, {adjNode, cost + edW}});
                }
            }
        }
        // If the destination node is unreachable return ‘-1’
        // else return the calculated dist from src to dst.
        if (dist[destination] == 1e9)
            return -1;
        return dist[destination];
}


/*
Time Complexity:
O( N ) { Additional log(N) of time eliminated here because we’re using a simple queue rather than a priority queue which is usually 
used in Dijkstra’s Algorithm }.
Where N = Number of flights / Number of edges.

Space Complexity:  
O( |E| + |V| ) { for the adjacency list, priority queue, and the dist array }.
Where E = Number of edges (flights.size()) and V = Number of Airports.

*/

//SOLVE ON CODING NINJA
